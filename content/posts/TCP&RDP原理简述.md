---
title: "TCP&RDP原理简述"
date: 2020-03-04T04:41:04+08:00
Categories : ["计算机基础", "网络"]
Tags : ["总结"]
---
# RDT & TCP
本文总结了可靠数据传输协议（RDT）和传输控制协议（TCP）的原理和工作方法，主要参考了《自顶向下》。
# 可靠数据传输原理
## 为什么需要RDT协议？
RDT位于运输层，其下方的网络层，链路层均不是可靠的，在下面的层上传输数据，数据可能会丢失（丢包），可能会损坏（bit翻转），也可能会乱序发送。为了保证上层应用层的应用程序能够正常地工作，需要在运输层构建可靠的数据传输协议，保证接收方得到的数据的完整和正确。

下面，我们会从最完美的假设开始构建RDT协议，再逐步地模拟真实通信的情况，进而完善RDT协议。
## 本文的约定
在发送方，应用层通过rdt_send()调用rdt协议传输数据，运输层通过udt_send()调用网络层发送数据。

在接收方，运输层通过rdt_rcv()调用网络层接收数据，运输层再通过deliver_data操作将确认的报文传给应用层协议。

应用层使用AL（Application Layer）表示，运输层使用TL（Transportation Layer）表示，网络层使用NL（Network Layer）表示。

1，2，3，4等序号表明一次网络通信过程中双方交互的动作顺序。
## RDT 1.0
RDT 1.0对于底层信道的假设是完全可靠的，因此不需要设计任何附加的措施来保证数据可靠传输。

**发送方**：当应用层准备好发送数据时，只需调用rdt_send()传给运输层，运输层直接加上报文头发给网络层。

**接收方**：当网络层收到数据时，只需调用rdt_rcv()传给运输层，运输层直接多路分解发送给应用层。
## RDT 2 Series
RDT 2 Series假设分组中的位可能受损，导致数据损坏。但是还是不会丢包。
### RDT 2.0

考虑一个生活中的例子：A给B打电话，B准确地收到了A的消息后会说“OK”（用ACK信号表示），示意A继续说，如果A说了一句模糊不清的话，B会说“没听清”（用NAK信号表示），示意A重说一遍刚才的话。这里的ACK和NAK就是两个控制报文，控制报文可以让发送方知道哪些内容被正确接收，哪些内容接收有误并且需要重传。

在计算机网络中，进行位差错检测有多种算法，这些算法通常会在报文上附加几个检测位，并且这些算法从数学上保证了正确。

**发送方**：

1.AL调用rdt_send()后，TL生成运输层报文，然后调用udt_send()发给NL。然后发送方开始等待接收方的控制报文。

3.如果收到ACK报文，转回1，如果收到NAK报文，重传数据包，直到收到ACK为止。

**接收方**：

2.NL收到数据，调rdt_rcv()发给运输层，然后运输层检测数据位错误，如果没错，发送ACK报文给发送方，如果有错，发送NAK报文给发送方。

当发送方收到接收方的控制报文之前，不可以发送下一个数据，只能等着，因此RDT 2.0是一个停等协议。
### RDT 2.1
在RDT 2.0中，没有考虑到ACK和NAK控制报文受损的情况，我们采用在报文中添加一个数据分组的序号字段来解决这个问题，对于停等协议，0和1两个标志就足够了，因为我们只需要区分目前

**发送方**：

1.AL调用rdt_send()，TL发送0号分组给NL，转入等待接收方控制报文状态。

3.如果收到控制报文，发现或者分组损坏或者是NAK，则重传0号分组，发现是ACK，则等待AL准备好1号分组。

4.AL调用rdt_send()，TL发送1号分组给NL，转入等待接收方控制报文状态。

6.如果收到控制报文，发现或者分组损坏或者是NAK，则重传1号分组，发现是ACK，则等待AL准备好0号分组。

**接收方**：

2.等待发送方的0号分组，NL收到后发给TL，TL检验后若有错，传回NAK，若没错，并且是0号分组，传回ACK，进入等待1号报文的状态。

5.等待发送方的1号分组，NL收到后发给TL，TL检验后若有错，传回NAK。若没错，并且是0号分组，证明第2步发送的ACK报文损坏，导致发送方重传0号分组，现在只需要传回ACK，再接着等待1号分组就可以了。若没错，并且是1号分组，则传回ACK，进入等待0号报文的状态。

### RDT 2.2

其实NAK控制报文也是不需要的，假设接收方已经确认了0号报文，发回了ACK0，然后接受1号报文时发现了报文损坏，则再次发回ACK0，发送方收到两个ACK0，就知道接收方没有正确收到0号报文之后的报文，这就是RDT 2.2相对于2.1的改进。

**发送方**：

1.AL调用rdt_send()，TL发送0号分组给NL，转入等待接收方控制报文状态。

3.如果收到控制报文，发现或者分组损坏或者是ACK1，则重传0号分组，发现是ACK0，则等待AL准备好1号分组。

4.AL调用rdt_send()，TL发送1号分组给NL，转入等待接收方控制报文状态。

6.如果收到控制报文，发现或者分组损坏或者是ACK0，则重传1号分组，发现是ACK1，则等待AL准备好0号分组。

**接收方**：

2.等待发送方的0号分组，NL收到后发给TL，TL检验后若有错或者是1号分组，则传回ACK1，并继续等待0号分组。若没错并且是0号分组，则发送ACK0，进入等待1号分组的状态。

5.如果收到控制报文，若发现分组损坏，则返回ACK0（要求重传1号分组），若发现是0号分组（证明上次ACK0传输出错，发送方重传0号分组），则返回ACK0，继续等待1号分组。若发现是1号分组，传回ACK1，进入等待0号分组的状态。

## RDT 3.0
RDT 3.0假设信道不仅会出错，还会出现丢包。

RDT 3.0让发送方负责检测和解决丢包，假设发送方发送了一个分组，该分组或者接收方的ACK发生了丢包，这两种情况下发送方都收不到任何响应，如果发送方等待了足够长的时间并确定分组已经丢失，则只需要重传该分组即可。如果等待时间设置错误（过短），导致的冗余分组的处理方法RDT 2.2已经涉及，即采用分组序号。

在RDT 3.0中，为了实现基于时间的重传机制，设置了一个倒数定时器，在规定的时间过后会中断发送方。发送方需要做到：

1. 每次发送一个分组时，启动一个定时器。
2. 采取适当的动作响应定时器中断。
3. 当分组确认后，终止定时器。

相较于RDT 2.2，RDT3.0的变化就是发送方发送分组后启动定时器，等待ACK时若定时器超时就重传并重启定时器，若收到正确的ACK就关闭定时器。

## 流水线RDT

由于上面涉及到的RDT是一个串行的停等协议，对于通信链路的利用率低的可怕，因此可以对发送方进行流水线化改造，即允许发送方在收到上一个分组的ACK之前就发送下一个分组，为了进行多个分组的同时传输，现在有必要为每个分组指定唯一的分组序号，同时发送方和接收方要可以缓存多个分组。有两种可以解决流水线错误的协议。

### 回退N步协议（Go Back N-Steps，GBN）
事实上就是滑窗法，发送方维护一个当前发送分组的窗口，如果n号分组和之前的分组全部确认，接收方才返回ACKn信号，只要发生乱序（提前收到之后的分组，我要5号你给我6号）直接丢弃分组，并返回最后一个有序的分组n的ACKn，然后发送方重传n+1号及之后的分组，这种确认方法被称为累积确认。

### 选择重传（Selective Repeat，SR）
在GBN中，单个分组的出错就能引起大量重传，事实上很多分组没有必要重传，这样做就造成了性能下降。SR的做法是在接收方也维护一个窗口，
窗口的左端点是顺序接收的最后一个分组的下一个，只要在窗口范围内的分组，哪怕失序到达也可以先缓存好。

# 传输控制协议（TCP）工作方式
在保证数据可靠传输方面，TCP的基本原理和上述RDT一致，下面就流量控制，拥塞控制和连接管理等方面来讨论TCP协议。

## 流量控制
一条TCP链接的每侧主机都为该链接设置了缓存，如果发送方发送数据太快而接收方读取缓存数据太慢（比如接收方正在忙别的）
就会导致接收方缓存溢出，流量控制机制即为解决这个问题而诞生。事实上流量控制是一个速度匹配服务。

流量控制依靠在TCP报文中加入对本机的剩余缓存量实现。最终达到互相通知缓存剩余量的目的。

## 连接管理
这里讨论了建立和拆除一条TCP连接时发生的事情。三次握手四次挥手的详细步骤见《自顶向下》。

下面引用了[知乎上的一个回答](https://www.zhihu.com/question/24853633/answer/115173386)
>TCP可靠传输的精髓： TCP连接的一方A，由操作系统动态随机选取一个32位长的序列号(Initial Sequence Number)，假设A的初始序列号为1000，以该序列号为原点，对自己将要发送的每个字节的数据进行编号，1001, 1002，1003..... 并把自己的初始序列号ISN告诉B，让B有一个思想准备，什么样编号的数据是合法的，什么编号是非法的，比如编号900就是非法的，同时B还可以对A每一个编号的字节数据进行确认。如果A收到B确认编号为2001，则意味着字节编号为1001-2000，共1000个字节已经安全到达。

>同理B也是类似的操作，假设B的初始序列号ISN为2000，以该序列号为原点，对自己将要发送的每个字节的数据进行编号，2001， 2002， 2003.... 并把自己的初始序列号ISN告诉A，以便A可以确认B发送的每一个字节。如果B收到A确认编号为4001,则意味着字节编号为2001-4000,共2000个字节已经安全到达。

>一句话概括，TCP连接握手，握的就是通信双方数据原点的序列号!

## 拥塞控制
总地来说，拥塞是由于发送速率过快，中间路由器缓存或者通信链路容量不足而导致的丢包。

